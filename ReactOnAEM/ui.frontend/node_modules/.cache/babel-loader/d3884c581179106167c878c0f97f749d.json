{"ast":null,"code":"import htmlDecodeTree from \"./generated/decode-data-html.js\";\nimport xmlDecodeTree from \"./generated/decode-data-xml.js\";\nimport decodeCodePoint, { replaceCodePoint, fromCodePoint } from \"./decode_codepoint.js\";\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree, xmlDecodeTree, decodeCodePoint };\nexport { replaceCodePoint, fromCodePoint } from \"./decode_codepoint.js\";\nvar CharCodes;\n(function (CharCodes) {\n  CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n  CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n  CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n  CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n  CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n  CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n  CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n  CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n  CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n  CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n  CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n  CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 0b100000;\nexport var BinTrieFlags;\n(function (BinTrieFlags) {\n  BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n  BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction isNumber(code) {\n  return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;\n}\nfunction isAsciiAlphaNumeric(code) {\n  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n  EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n  EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n  EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n  EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nexport var DecodingMode;\n(function (DecodingMode) {\n  /** Entities in text nodes that can end with any character. */\n  DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n  /** Only allow entities terminated with a semicolon. */\n  DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n  /** Entities in attributes have limitations on ending characters. */\n  DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode || (DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nexport class EntityDecoder {\n  constructor( /** The tree used to decode entities. */\n  decodeTree,\n  /**\n   * The function that is called when a codepoint is decoded.\n   *\n   * For multi-byte named entities, this will be called multiple times,\n   * with the second codepoint, and the same `consumed` value.\n   *\n   * @param codepoint The decoded codepoint.\n   * @param consumed The number of bytes consumed by the decoder.\n   */\n  emitCodePoint, /** An object that is used to produce errors. */\n  errors) {\n    this.decodeTree = decodeTree;\n    this.emitCodePoint = emitCodePoint;\n    this.errors = errors;\n    /** The current state of the decoder. */\n    this.state = EntityDecoderState.EntityStart;\n    /** Characters that were consumed while parsing an entity. */\n    this.consumed = 1;\n    /**\n     * The result of the entity.\n     *\n     * Either the result index of a numeric entity, or the codepoint of a\n     * numeric entity.\n     */\n    this.result = 0;\n    /** The current index in the decode tree. */\n    this.treeIndex = 0;\n    /** The number of characters that were consumed in excess. */\n    this.excess = 1;\n    /** The mode in which the decoder is operating. */\n    this.decodeMode = DecodingMode.Strict;\n  }\n  /** Resets the instance to make it reusable. */\n  startEntity(decodeMode) {\n    this.decodeMode = decodeMode;\n    this.state = EntityDecoderState.EntityStart;\n    this.result = 0;\n    this.treeIndex = 0;\n    this.excess = 1;\n    this.consumed = 1;\n  }\n  /**\n   * Write an entity to the decoder. This can be called multiple times with partial entities.\n   * If the entity is incomplete, the decoder will return -1.\n   *\n   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n   * entity is incomplete, and resume when the next string is written.\n   *\n   * @param string The string containing the entity (or a continuation of the entity).\n   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  write(str, offset) {\n    switch (this.state) {\n      case EntityDecoderState.EntityStart:\n        {\n          if (str.charCodeAt(offset) === CharCodes.NUM) {\n            this.state = EntityDecoderState.NumericStart;\n            this.consumed += 1;\n            return this.stateNumericStart(str, offset + 1);\n          }\n          this.state = EntityDecoderState.NamedEntity;\n          return this.stateNamedEntity(str, offset);\n        }\n      case EntityDecoderState.NumericStart:\n        {\n          return this.stateNumericStart(str, offset);\n        }\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.stateNumericDecimal(str, offset);\n        }\n      case EntityDecoderState.NumericHex:\n        {\n          return this.stateNumericHex(str, offset);\n        }\n      case EntityDecoderState.NamedEntity:\n        {\n          return this.stateNamedEntity(str, offset);\n        }\n    }\n  }\n  /**\n   * Switches between the numeric decimal and hexadecimal states.\n   *\n   * Equivalent to the `Numeric character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericStart(str, offset) {\n    if (offset >= str.length) {\n      return -1;\n    }\n    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n      this.state = EntityDecoderState.NumericHex;\n      this.consumed += 1;\n      return this.stateNumericHex(str, offset + 1);\n    }\n    this.state = EntityDecoderState.NumericDecimal;\n    return this.stateNumericDecimal(str, offset);\n  }\n  addToNumericResult(str, start, end, base) {\n    if (start !== end) {\n      const digitCount = end - start;\n      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);\n      this.consumed += digitCount;\n    }\n  }\n  /**\n   * Parses a hexadecimal numeric entity.\n   *\n   * Equivalent to the `Hexademical character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericHex(str, offset) {\n    const startIdx = offset;\n    while (offset < str.length) {\n      const char = str.charCodeAt(offset);\n      if (isNumber(char) || isHexadecimalCharacter(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return this.emitNumericEntity(char, 3);\n      }\n    }\n    this.addToNumericResult(str, startIdx, offset, 16);\n    return -1;\n  }\n  /**\n   * Parses a decimal numeric entity.\n   *\n   * Equivalent to the `Decimal character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNumericDecimal(str, offset) {\n    const startIdx = offset;\n    while (offset < str.length) {\n      const char = str.charCodeAt(offset);\n      if (isNumber(char)) {\n        offset += 1;\n      } else {\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return this.emitNumericEntity(char, 2);\n      }\n    }\n    this.addToNumericResult(str, startIdx, offset, 10);\n    return -1;\n  }\n  /**\n   * Validate and emit a numeric entity.\n   *\n   * Implements the logic from the `Hexademical character reference start\n   * state` and `Numeric character reference end state` in the HTML spec.\n   *\n   * @param lastCp The last code point of the entity. Used to see if the\n   *               entity was terminated with a semicolon.\n   * @param expectedLength The minimum number of characters that should be\n   *                       consumed. Used to validate that at least one digit\n   *                       was consumed.\n   * @returns The number of characters that were consumed.\n   */\n  emitNumericEntity(lastCp, expectedLength) {\n    var _a;\n    // Ensure we consumed at least one digit.\n    if (this.consumed <= expectedLength) {\n      (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n      return 0;\n    }\n    // Figure out if this is a legit end of the entity\n    if (lastCp === CharCodes.SEMI) {\n      this.consumed += 1;\n    } else if (this.decodeMode === DecodingMode.Strict) {\n      return 0;\n    }\n    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);\n    if (this.errors) {\n      if (lastCp !== CharCodes.SEMI) {\n        this.errors.missingSemicolonAfterCharacterReference();\n      }\n      this.errors.validateNumericCharacterReference(this.result);\n    }\n    return this.consumed;\n  }\n  /**\n   * Parses a named entity.\n   *\n   * Equivalent to the `Named character reference state` in the HTML spec.\n   *\n   * @param str The string containing the entity (or a continuation of the entity).\n   * @param offset The current offset.\n   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n   */\n  stateNamedEntity(str, offset) {\n    const {\n      decodeTree\n    } = this;\n    let current = decodeTree[this.treeIndex];\n    // The mask is the number of bytes of the value, including the current byte.\n    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n    for (; offset < str.length; offset++, this.excess++) {\n      const char = str.charCodeAt(offset);\n      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n      if (this.treeIndex < 0) {\n        return this.result === 0 ||\n        // If we are parsing an attribute\n        this.decodeMode === DecodingMode.Attribute && (\n        // We shouldn't have consumed any characters after the entity,\n        valueLength === 0 ||\n        // And there should be no invalid characters.\n        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();\n      }\n      current = decodeTree[this.treeIndex];\n      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n      // If the branch is a value, store it and continue\n      if (valueLength !== 0) {\n        // If the entity is terminated by a semicolon, we are done.\n        if (char === CharCodes.SEMI) {\n          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n        }\n        // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n        if (this.decodeMode !== DecodingMode.Strict) {\n          this.result = this.treeIndex;\n          this.consumed += this.excess;\n          this.excess = 0;\n        }\n      }\n    }\n    return -1;\n  }\n  /**\n   * Emit a named entity that was not terminated with a semicolon.\n   *\n   * @returns The number of characters consumed.\n   */\n  emitNotTerminatedNamedEntity() {\n    var _a;\n    const {\n      result,\n      decodeTree\n    } = this;\n    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n    this.emitNamedEntityData(result, valueLength, this.consumed);\n    (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n    return this.consumed;\n  }\n  /**\n   * Emit a named entity.\n   *\n   * @param result The index of the entity in the decode tree.\n   * @param valueLength The number of bytes in the entity.\n   * @param consumed The number of characters consumed.\n   *\n   * @returns The number of characters consumed.\n   */\n  emitNamedEntityData(result, valueLength, consumed) {\n    const {\n      decodeTree\n    } = this;\n    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);\n    if (valueLength === 3) {\n      // For multi-byte values, we need to emit the second byte.\n      this.emitCodePoint(decodeTree[result + 2], consumed);\n    }\n    return consumed;\n  }\n  /**\n   * Signal to the parser that the end of the input was reached.\n   *\n   * Remaining data will be emitted and relevant errors will be produced.\n   *\n   * @returns The number of characters consumed.\n   */\n  end() {\n    var _a;\n    switch (this.state) {\n      case EntityDecoderState.NamedEntity:\n        {\n          // Emit a named entity if we have one.\n          return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;\n        }\n      // Otherwise, emit a numeric entity if we have one.\n      case EntityDecoderState.NumericDecimal:\n        {\n          return this.emitNumericEntity(0, 2);\n        }\n      case EntityDecoderState.NumericHex:\n        {\n          return this.emitNumericEntity(0, 3);\n        }\n      case EntityDecoderState.NumericStart:\n        {\n          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n          return 0;\n        }\n      case EntityDecoderState.EntityStart:\n        {\n          // Return 0 if we have no entity.\n          return 0;\n        }\n    }\n  }\n}\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n  let ret = \"\";\n  const decoder = new EntityDecoder(decodeTree, str => ret += fromCodePoint(str));\n  return function decodeWithTrie(str, decodeMode) {\n    let lastIndex = 0;\n    let offset = 0;\n    while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n      ret += str.slice(lastIndex, offset);\n      decoder.startEntity(decodeMode);\n      const len = decoder.write(str,\n      // Skip the \"&\"\n      offset + 1);\n      if (len < 0) {\n        lastIndex = offset + decoder.end();\n        break;\n      }\n      lastIndex = offset + len;\n      // If `len` is 0, skip the current `&` and continue.\n      offset = len === 0 ? lastIndex + 1 : lastIndex;\n    }\n    const result = ret + str.slice(lastIndex);\n    // Make sure we don't keep a reference to the final string.\n    ret = \"\";\n    return result;\n  };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nexport function determineBranch(decodeTree, current, nodeIdx, char) {\n  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n  // Case 1: Single branch encoded in jump offset\n  if (branchCount === 0) {\n    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n  }\n  // Case 2: Multiple branches encoded in jump table\n  if (jumpOffset) {\n    const value = char - jumpOffset;\n    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;\n  }\n  // Case 3: Multiple branches encoded in dictionary\n  // Binary search for the character.\n  let lo = nodeIdx;\n  let hi = lo + branchCount - 1;\n  while (lo <= hi) {\n    const mid = lo + hi >>> 1;\n    const midVal = decodeTree[mid];\n    if (midVal < char) {\n      lo = mid + 1;\n    } else if (midVal > char) {\n      hi = mid - 1;\n    } else {\n      return decodeTree[mid + branchCount];\n    }\n  }\n  return -1;\n}\nconst htmlDecoder = getDecoder(htmlDecodeTree);\nconst xmlDecoder = getDecoder(xmlDecodeTree);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nexport function decodeHTML(str) {\n  let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DecodingMode.Legacy;\n  return htmlDecoder(str, mode);\n}\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLAttribute(str) {\n  return htmlDecoder(str, DecodingMode.Attribute);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(str) {\n  return htmlDecoder(str, DecodingMode.Strict);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(str) {\n  return xmlDecoder(str, DecodingMode.Strict);\n}","map":{"version":3,"sources":["decode.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/entities/61afd4701eaa736978b13c7351cd3de9a96b04bc/src/","sourcesContent":["import htmlDecodeTree from \"./generated/decode-data-html.js\";\nimport xmlDecodeTree from \"./generated/decode-data-xml.js\";\nimport decodeCodePoint, { replaceCodePoint, fromCodePoint, } from \"./decode_codepoint.js\";\n// Re-export for use by eg. htmlparser2\nexport { htmlDecodeTree, xmlDecodeTree, decodeCodePoint };\nexport { replaceCodePoint, fromCodePoint } from \"./decode_codepoint.js\";\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n    CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n    CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n    CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nconst TO_LOWER_BIT = 0b100000;\nexport var BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags || (BinTrieFlags = {}));\nfunction isNumber(code) {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));\n}\nfunction isAsciiAlphaNumeric(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code));\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n    EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n    EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n    EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nexport var DecodingMode;\n(function (DecodingMode) {\n    /** Entities in text nodes that can end with any character. */\n    DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n    /** Only allow entities terminated with a semicolon. */\n    DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n    /** Entities in attributes have limitations on ending characters. */\n    DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode || (DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nexport class EntityDecoder {\n    constructor(\n    /** The tree used to decode entities. */\n    decodeTree, \n    /**\n     * The function that is called when a codepoint is decoded.\n     *\n     * For multi-byte named entities, this will be called multiple times,\n     * with the second codepoint, and the same `consumed` value.\n     *\n     * @param codepoint The decoded codepoint.\n     * @param consumed The number of bytes consumed by the decoder.\n     */\n    emitCodePoint, \n    /** An object that is used to produce errors. */\n    errors) {\n        this.decodeTree = decodeTree;\n        this.emitCodePoint = emitCodePoint;\n        this.errors = errors;\n        /** The current state of the decoder. */\n        this.state = EntityDecoderState.EntityStart;\n        /** Characters that were consumed while parsing an entity. */\n        this.consumed = 1;\n        /**\n         * The result of the entity.\n         *\n         * Either the result index of a numeric entity, or the codepoint of a\n         * numeric entity.\n         */\n        this.result = 0;\n        /** The current index in the decode tree. */\n        this.treeIndex = 0;\n        /** The number of characters that were consumed in excess. */\n        this.excess = 1;\n        /** The mode in which the decoder is operating. */\n        this.decodeMode = DecodingMode.Strict;\n    }\n    /** Resets the instance to make it reusable. */\n    startEntity(decodeMode) {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n    }\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param string The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    write(str, offset) {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (str.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(str, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(str, offset);\n            }\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(str, offset);\n            }\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(str, offset);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(str, offset);\n            }\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(str, offset);\n            }\n        }\n    }\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericStart(str, offset) {\n        if (offset >= str.length) {\n            return -1;\n        }\n        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(str, offset + 1);\n        }\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(str, offset);\n    }\n    addToNumericResult(str, start, end, base) {\n        if (start !== end) {\n            const digitCount = end - start;\n            this.result =\n                this.result * Math.pow(base, digitCount) +\n                    parseInt(str.substr(start, digitCount), base);\n            this.consumed += digitCount;\n        }\n    }\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericHex(str, offset) {\n        const startIdx = offset;\n        while (offset < str.length) {\n            const char = str.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 16);\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return -1;\n    }\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNumericDecimal(str, offset) {\n        const startIdx = offset;\n        while (offset < str.length) {\n            const char = str.charCodeAt(offset);\n            if (isNumber(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 10);\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return -1;\n    }\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    emitNumericEntity(lastCp, expectedLength) {\n        var _a;\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n            return 0;\n        }\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        }\n        else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n        this.emitCodePoint(replaceCodePoint(this.result), this.consumed);\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n        return this.consumed;\n    }\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    stateNamedEntity(str, offset) {\n        const { decodeTree } = this;\n        let current = decodeTree[this.treeIndex];\n        // The mask is the number of bytes of the value, including the current byte.\n        let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n        for (; offset < str.length; offset++, this.excess++) {\n            const char = str.charCodeAt(offset);\n            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n                }\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n        }\n        return -1;\n    }\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNotTerminatedNamedEntity() {\n        var _a;\n        const { result, decodeTree } = this;\n        const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n        return this.consumed;\n    }\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    emitNamedEntityData(result, valueLength, consumed) {\n        const { decodeTree } = this;\n        this.emitCodePoint(valueLength === 1\n            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH\n            : decodeTree[result + 1], consumed);\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n        return consumed;\n    }\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    end() {\n        var _a;\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    }\n}\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n    let ret = \"\";\n    const decoder = new EntityDecoder(decodeTree, (str) => (ret += fromCodePoint(str)));\n    return function decodeWithTrie(str, decodeMode) {\n        let lastIndex = 0;\n        let offset = 0;\n        while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n            ret += str.slice(lastIndex, offset);\n            decoder.startEntity(decodeMode);\n            const len = decoder.write(str, \n            // Skip the \"&\"\n            offset + 1);\n            if (len < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n            lastIndex = offset + len;\n            // If `len` is 0, skip the current `&` and continue.\n            offset = len === 0 ? lastIndex + 1 : lastIndex;\n        }\n        const result = ret + str.slice(lastIndex);\n        // Make sure we don't keep a reference to the final string.\n        ret = \"\";\n        return result;\n    };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nexport function determineBranch(decodeTree, current, nodeIdx, char) {\n    const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    const jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        const value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    let lo = nodeIdx;\n    let hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        const mid = (lo + hi) >>> 1;\n        const midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nconst htmlDecoder = getDecoder(htmlDecodeTree);\nconst xmlDecoder = getDecoder(xmlDecodeTree);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nexport function decodeHTML(str, mode = DecodingMode.Legacy) {\n    return htmlDecoder(str, mode);\n}\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLAttribute(str) {\n    return htmlDecoder(str, DecodingMode.Attribute);\n}\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeHTMLStrict(str) {\n    return htmlDecoder(str, DecodingMode.Strict);\n}\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nexport function decodeXML(str) {\n    return xmlDecoder(str, DecodingMode.Strict);\n}\n//# sourceMappingURL=decode.js.map"]},"metadata":{},"sourceType":"module"}