{"ast":null,"code":"import { isTag, hasChildren } from \"domhandler\";\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function filter(test, node) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let limit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n  return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function find(test, nodes, recurse, limit) {\n  const result = [];\n  /** Stack of the arrays we are looking at. */\n  const nodeStack = [nodes];\n  /** Stack of the indices within the arrays. */\n  const indexStack = [0];\n  for (;;) {\n    // First, check if the current array has any more elements to look at.\n    if (indexStack[0] >= nodeStack[0].length) {\n      // If we have no more arrays to look at, we are done.\n      if (indexStack.length === 1) {\n        return result;\n      }\n      // Otherwise, remove the current array from the stack.\n      nodeStack.shift();\n      indexStack.shift();\n      // Loop back to the start to continue with the next array.\n      continue;\n    }\n    const elem = nodeStack[0][indexStack[0]++];\n    if (test(elem)) {\n      result.push(elem);\n      if (--limit <= 0) return result;\n    }\n    if (recurse && hasChildren(elem) && elem.children.length > 0) {\n      /*\n       * Add the children to the stack. We are depth-first, so this is\n       * the next array we look at.\n       */\n      indexStack.unshift(0);\n      nodeStack.unshift(elem.children);\n    }\n  }\n}\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nexport function findOneChild(test, nodes) {\n  return nodes.find(test);\n}\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nexport function findOne(test, nodes) {\n  let recurse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let elem = null;\n  for (let i = 0; i < nodes.length && !elem; i++) {\n    const node = nodes[i];\n    if (!isTag(node)) {\n      continue;\n    } else if (test(node)) {\n      elem = node;\n    } else if (recurse && node.children.length > 0) {\n      elem = findOne(test, node.children, true);\n    }\n  }\n  return elem;\n}\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nexport function existsOne(test, nodes) {\n  return nodes.some(checked => isTag(checked) && (test(checked) || existsOne(test, checked.children)));\n}\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nexport function findAll(test, nodes) {\n  const result = [];\n  const nodeStack = [nodes];\n  const indexStack = [0];\n  for (;;) {\n    if (indexStack[0] >= nodeStack[0].length) {\n      if (nodeStack.length === 1) {\n        return result;\n      }\n      // Otherwise, remove the current array from the stack.\n      nodeStack.shift();\n      indexStack.shift();\n      // Loop back to the start to continue with the next array.\n      continue;\n    }\n    const elem = nodeStack[0][indexStack[0]++];\n    if (!isTag(elem)) continue;\n    if (test(elem)) result.push(elem);\n    if (elem.children.length > 0) {\n      indexStack.unshift(0);\n      nodeStack.unshift(elem.children);\n    }\n  }\n}","map":{"version":3,"sources":["querying.ts"],"names":[],"mappings":"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","sourceRoot":"https://raw.githubusercontent.com/fb55/domutils/96c989e159c98218958f375ea04210f2d1b43c0c/src/","sourcesContent":["import { isTag, hasChildren } from \"domhandler\";\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function filter(test, node, recurse = true, limit = Infinity) {\n    return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nexport function find(test, nodes, recurse, limit) {\n    const result = [];\n    /** Stack of the arrays we are looking at. */\n    const nodeStack = [nodes];\n    /** Stack of the indices within the arrays. */\n    const indexStack = [0];\n    for (;;) {\n        // First, check if the current array has any more elements to look at.\n        if (indexStack[0] >= nodeStack[0].length) {\n            // If we have no more arrays to look at, we are done.\n            if (indexStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        const elem = nodeStack[0][indexStack[0]++];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                return result;\n        }\n        if (recurse && hasChildren(elem) && elem.children.length > 0) {\n            /*\n             * Add the children to the stack. We are depth-first, so this is\n             * the next array we look at.\n             */\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nexport function findOneChild(test, nodes) {\n    return nodes.find(test);\n}\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nexport function findOne(test, nodes, recurse = true) {\n    let elem = null;\n    for (let i = 0; i < nodes.length && !elem; i++) {\n        const node = nodes[i];\n        if (!isTag(node)) {\n            continue;\n        }\n        else if (test(node)) {\n            elem = node;\n        }\n        else if (recurse && node.children.length > 0) {\n            elem = findOne(test, node.children, true);\n        }\n    }\n    return elem;\n}\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nexport function existsOne(test, nodes) {\n    return nodes.some((checked) => isTag(checked) &&\n        (test(checked) || existsOne(test, checked.children)));\n}\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nexport function findAll(test, nodes) {\n    const result = [];\n    const nodeStack = [nodes];\n    const indexStack = [0];\n    for (;;) {\n        if (indexStack[0] >= nodeStack[0].length) {\n            if (nodeStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        const elem = nodeStack[0][indexStack[0]++];\n        if (!isTag(elem))\n            continue;\n        if (test(elem))\n            result.push(elem);\n        if (elem.children.length > 0) {\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\n//# sourceMappingURL=querying.js.map"]},"metadata":{},"sourceType":"module"}