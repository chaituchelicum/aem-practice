{"ast":null,"code":"import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport class Node {\n  constructor() {\n    /** Parent of the node */\n    this.parent = null;\n    /** Previous sibling */\n    this.prev = null;\n    /** Next sibling */\n    this.next = null;\n    /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n    this.startIndex = null;\n    /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n    this.endIndex = null;\n  }\n  // Read-write aliases for properties\n  /**\n   * Same as {@link parent}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get parentNode() {\n    return this.parent;\n  }\n  set parentNode(parent) {\n    this.parent = parent;\n  }\n  /**\n   * Same as {@link prev}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get previousSibling() {\n    return this.prev;\n  }\n  set previousSibling(prev) {\n    this.prev = prev;\n  }\n  /**\n   * Same as {@link next}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get nextSibling() {\n    return this.next;\n  }\n  set nextSibling(next) {\n    this.next = next;\n  }\n  /**\n   * Clone this node, and optionally its children.\n   *\n   * @param recursive Clone child nodes as well.\n   * @returns A clone of the node.\n   */\n  cloneNode() {\n    let recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return cloneNode(this, recursive);\n  }\n}\n/**\n * A node that contains some data.\n */\nexport class DataNode extends Node {\n  /**\n   * @param data The content of the data node\n   */\n  constructor(data) {\n    super();\n    this.data = data;\n  }\n  /**\n   * Same as {@link data}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get nodeValue() {\n    return this.data;\n  }\n  set nodeValue(data) {\n    this.data = data;\n  }\n}\n/**\n * Text within the document.\n */\nexport class Text extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Text;\n  }\n  get nodeType() {\n    return 3;\n  }\n}\n/**\n * Comments within the document.\n */\nexport class Comment extends DataNode {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Comment;\n  }\n  get nodeType() {\n    return 8;\n  }\n}\n/**\n * Processing instructions, including doc types.\n */\nexport class ProcessingInstruction extends DataNode {\n  constructor(name, data) {\n    super(data);\n    this.name = name;\n    this.type = ElementType.Directive;\n  }\n  get nodeType() {\n    return 1;\n  }\n}\n/**\n * A `Node` that can have children.\n */\nexport class NodeWithChildren extends Node {\n  /**\n   * @param children Children of the node. Only certain node types can have children.\n   */\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n  // Aliases\n  /** First child of the node. */\n  get firstChild() {\n    var _a;\n    return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n  }\n  /** Last child of the node. */\n  get lastChild() {\n    return this.children.length > 0 ? this.children[this.children.length - 1] : null;\n  }\n  /**\n   * Same as {@link children}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get childNodes() {\n    return this.children;\n  }\n  set childNodes(children) {\n    this.children = children;\n  }\n}\nexport class CDATA extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.CDATA;\n  }\n  get nodeType() {\n    return 4;\n  }\n}\n/**\n * The root node of the document.\n */\nexport class Document extends NodeWithChildren {\n  constructor() {\n    super(...arguments);\n    this.type = ElementType.Root;\n  }\n  get nodeType() {\n    return 9;\n  }\n}\n/**\n * An element within the DOM.\n */\nexport class Element extends NodeWithChildren {\n  /**\n   * @param name Name of the tag, eg. `div`, `span`.\n   * @param attribs Object mapping attribute names to attribute values.\n   * @param children Children of the node.\n   */\n  constructor(name, attribs) {\n    let children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag;\n    super(children);\n    this.name = name;\n    this.attribs = attribs;\n    this.type = type;\n  }\n  get nodeType() {\n    return 1;\n  }\n  // DOM Level 1 aliases\n  /**\n   * Same as {@link name}.\n   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n   */\n  get tagName() {\n    return this.name;\n  }\n  set tagName(name) {\n    this.name = name;\n  }\n  get attributes() {\n    return Object.keys(this.attribs).map(name => {\n      var _a, _b;\n      return {\n        name,\n        value: this.attribs[name],\n        namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n        prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name]\n      };\n    });\n  }\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n  return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n  return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n  return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n  return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n  return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n  return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n  return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nexport function cloneNode(node) {\n  let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let result;\n  if (isText(node)) {\n    result = new Text(node.data);\n  } else if (isComment(node)) {\n    result = new Comment(node.data);\n  } else if (isTag(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Element(node.name, {\n      ...node.attribs\n    }, children);\n    children.forEach(child => child.parent = clone);\n    if (node.namespace != null) {\n      clone.namespace = node.namespace;\n    }\n    if (node[\"x-attribsNamespace\"]) {\n      clone[\"x-attribsNamespace\"] = {\n        ...node[\"x-attribsNamespace\"]\n      };\n    }\n    if (node[\"x-attribsPrefix\"]) {\n      clone[\"x-attribsPrefix\"] = {\n        ...node[\"x-attribsPrefix\"]\n      };\n    }\n    result = clone;\n  } else if (isCDATA(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new CDATA(children);\n    children.forEach(child => child.parent = clone);\n    result = clone;\n  } else if (isDocument(node)) {\n    const children = recursive ? cloneChildren(node.children) : [];\n    const clone = new Document(children);\n    children.forEach(child => child.parent = clone);\n    if (node[\"x-mode\"]) {\n      clone[\"x-mode\"] = node[\"x-mode\"];\n    }\n    result = clone;\n  } else if (isDirective(node)) {\n    const instruction = new ProcessingInstruction(node.name, node.data);\n    if (node[\"x-name\"] != null) {\n      instruction[\"x-name\"] = node[\"x-name\"];\n      instruction[\"x-publicId\"] = node[\"x-publicId\"];\n      instruction[\"x-systemId\"] = node[\"x-systemId\"];\n    }\n    result = instruction;\n  } else {\n    throw new Error(`Not implemented yet: ${node.type}`);\n  }\n  result.startIndex = node.startIndex;\n  result.endIndex = node.endIndex;\n  if (node.sourceCodeLocation != null) {\n    result.sourceCodeLocation = node.sourceCodeLocation;\n  }\n  return result;\n}\nfunction cloneChildren(childs) {\n  const children = childs.map(child => cloneNode(child, true));\n  for (let i = 1; i < children.length; i++) {\n    children[i].prev = children[i - 1];\n    children[i - 1].next = children[i];\n  }\n  return children;\n}","map":{"version":3,"names":["ElementType","isTag","isTagRaw","Node","constructor","parent","prev","next","startIndex","endIndex","parentNode","previousSibling","nextSibling","cloneNode","recursive","arguments","length","undefined","DataNode","data","nodeValue","Text","type","nodeType","Comment","ProcessingInstruction","name","Directive","NodeWithChildren","children","firstChild","_a","lastChild","childNodes","CDATA","Document","Root","Element","attribs","Script","Style","Tag","tagName","attributes","Object","keys","map","_b","value","namespace","prefix","node","isCDATA","isText","isComment","isDirective","isDocument","hasChildren","prototype","hasOwnProperty","call","result","cloneChildren","clone","forEach","child","instruction","Error","sourceCodeLocation","childs","i"],"sources":["/Users/surendrakti/Desktop/Chaitanya/AEM/SPA_AEM/ReactOnAEM/ui.frontend/node_modules/domhandler/lib/esm/node.js"],"sourcesContent":["import { ElementType, isTag as isTagRaw } from \"domelementtype\";\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nexport class Node {\n    constructor() {\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    // Read-write aliases for properties\n    /**\n     * Same as {@link parent}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get parentNode() {\n        return this.parent;\n    }\n    set parentNode(parent) {\n        this.parent = parent;\n    }\n    /**\n     * Same as {@link prev}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get previousSibling() {\n        return this.prev;\n    }\n    set previousSibling(prev) {\n        this.prev = prev;\n    }\n    /**\n     * Same as {@link next}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nextSibling() {\n        return this.next;\n    }\n    set nextSibling(next) {\n        this.next = next;\n    }\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    cloneNode(recursive = false) {\n        return cloneNode(this, recursive);\n    }\n}\n/**\n * A node that contains some data.\n */\nexport class DataNode extends Node {\n    /**\n     * @param data The content of the data node\n     */\n    constructor(data) {\n        super();\n        this.data = data;\n    }\n    /**\n     * Same as {@link data}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get nodeValue() {\n        return this.data;\n    }\n    set nodeValue(data) {\n        this.data = data;\n    }\n}\n/**\n * Text within the document.\n */\nexport class Text extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Text;\n    }\n    get nodeType() {\n        return 3;\n    }\n}\n/**\n * Comments within the document.\n */\nexport class Comment extends DataNode {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Comment;\n    }\n    get nodeType() {\n        return 8;\n    }\n}\n/**\n * Processing instructions, including doc types.\n */\nexport class ProcessingInstruction extends DataNode {\n    constructor(name, data) {\n        super(data);\n        this.name = name;\n        this.type = ElementType.Directive;\n    }\n    get nodeType() {\n        return 1;\n    }\n}\n/**\n * A `Node` that can have children.\n */\nexport class NodeWithChildren extends Node {\n    /**\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    constructor(children) {\n        super();\n        this.children = children;\n    }\n    // Aliases\n    /** First child of the node. */\n    get firstChild() {\n        var _a;\n        return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /** Last child of the node. */\n    get lastChild() {\n        return this.children.length > 0\n            ? this.children[this.children.length - 1]\n            : null;\n    }\n    /**\n     * Same as {@link children}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get childNodes() {\n        return this.children;\n    }\n    set childNodes(children) {\n        this.children = children;\n    }\n}\nexport class CDATA extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.CDATA;\n    }\n    get nodeType() {\n        return 4;\n    }\n}\n/**\n * The root node of the document.\n */\nexport class Document extends NodeWithChildren {\n    constructor() {\n        super(...arguments);\n        this.type = ElementType.Root;\n    }\n    get nodeType() {\n        return 9;\n    }\n}\n/**\n * An element within the DOM.\n */\nexport class Element extends NodeWithChildren {\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    constructor(name, attribs, children = [], type = name === \"script\"\n        ? ElementType.Script\n        : name === \"style\"\n            ? ElementType.Style\n            : ElementType.Tag) {\n        super(children);\n        this.name = name;\n        this.attribs = attribs;\n        this.type = type;\n    }\n    get nodeType() {\n        return 1;\n    }\n    // DOM Level 1 aliases\n    /**\n     * Same as {@link name}.\n     * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n     */\n    get tagName() {\n        return this.name;\n    }\n    set tagName(name) {\n        this.name = name;\n    }\n    get attributes() {\n        return Object.keys(this.attribs).map((name) => {\n            var _a, _b;\n            return ({\n                name,\n                value: this.attribs[name],\n                namespace: (_a = this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                prefix: (_b = this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n            });\n        });\n    }\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nexport function isTag(node) {\n    return isTagRaw(node);\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nexport function isCDATA(node) {\n    return node.type === ElementType.CDATA;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nexport function isText(node) {\n    return node.type === ElementType.Text;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nexport function isComment(node) {\n    return node.type === ElementType.Comment;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDirective(node) {\n    return node.type === ElementType.Directive;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nexport function isDocument(node) {\n    return node.type === ElementType.Root;\n}\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nexport function hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nexport function cloneNode(node, recursive = false) {\n    let result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Element(node.name, { ...node.attribs }, children);\n        children.forEach((child) => (child.parent = clone));\n        if (node.namespace != null) {\n            clone.namespace = node.namespace;\n        }\n        if (node[\"x-attribsNamespace\"]) {\n            clone[\"x-attribsNamespace\"] = { ...node[\"x-attribsNamespace\"] };\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone[\"x-attribsPrefix\"] = { ...node[\"x-attribsPrefix\"] };\n        }\n        result = clone;\n    }\n    else if (isCDATA(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new CDATA(children);\n        children.forEach((child) => (child.parent = clone));\n        result = clone;\n    }\n    else if (isDocument(node)) {\n        const children = recursive ? cloneChildren(node.children) : [];\n        const clone = new Document(children);\n        children.forEach((child) => (child.parent = clone));\n        if (node[\"x-mode\"]) {\n            clone[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone;\n    }\n    else if (isDirective(node)) {\n        const instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(`Not implemented yet: ${node.type}`);\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    if (node.sourceCodeLocation != null) {\n        result.sourceCodeLocation = node.sourceCodeLocation;\n    }\n    return result;\n}\nfunction cloneChildren(childs) {\n    const children = childs.map((child) => cloneNode(child, true));\n    for (let i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}